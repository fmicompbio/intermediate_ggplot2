---
title: "Intermediate ggplot2 - tips and tricks"
author: "Charlotte Soneson, Michael Stadler"
date: "`r Sys.Date()`"
format: 
    html:
        toc: true
editor_options: 
  chunk_output_type: console
---


# Load packages

```{r}
suppressPackageStartupMessages({
    ## data manipulation
    library(scales)
    library(forcats)
    library(dplyr)
    library(tidyr)
    ## ggplot2 + extension packages
    library(ggplot2)
    library(ggforce)
    library(ggalt)
    library(ggridges)
    library(GGally)
    library(ggsignif)
    library(ggstatsplot)
    library(gghighlight)
    library(ggrepel)
    library(ggtext)
    library(ggnewscale)
    ## packages to combine multiple figures
    library(patchwork)
    library(cowplot)
    ## packages for interactive graphics
    library(plotly)
    library(ggiraph)
    ## color packages
    library(RColorBrewer)
    library(circlize)
    ## other packages
    library(sessioninfo)
    library(fueleconomy)
})
```

# A quick look at the data

We will use two different data sets to illustrate the tips and tricks in this 
document. 
The first one comes from the `fueleconomy` package, and provides fuel economy 
data from the EPA between the years 1985 and 2015. 
We subset the data to only the vehicles from the year 2000 or later. 

```{r}
(df <- vehicles %>%
     dplyr::filter(year >= 2000))
```

The second data set is provided with the `ggplot2` package, and contains data 
on a set of diamonds. 

```{r}
diamonds
```

# Defining a general theme

Before we start making plots, we define a theme that we will apply to all 
plots that we generate.
There are many ways of doing this - arguably the most straightforward is to 
assign the theme-related parts of a `ggplot` call to a variable, and add 
this variable to all subsequent plots. 

```{r}
## Define theme variable
ggp <- theme_bw() + 
    theme(axis.text = element_text(size = 11),
          axis.title = element_text(size = 12),
          strip.text = element_text(size = 12),
          title = element_text(size = 13))

## Use in any ggplot (take care to put it in the right position in the call
## if the plot itself defines theme aspects)
ggplot(df, aes(x = fuel)) + 
    geom_bar() + coord_flip() + 
    ggp
```

It is also possible to set the default theme that is used for all plots in 
the session. 
For example, to make `theme_bw()` the default theme, we could do:

```{r, eval = FALSE}
old <- theme_set(theme_bw())
```

`ggplot2` also contains functions for replacing specific elements of a theme, see 
[here](https://ggplot2.tidyverse.org/reference/theme_get.html) for an overview.

# Changing order of factor levels with the `forcats` package

In this section, we will illustrate how to use the `forcats` package to reorder
the levels of a factor "on the fly". Arguably, this is not strictly (gg)plot 
related, and it can be applied to any factor; however, it is often useful to be 
able to reorder factor levels to obtain the most informative graphical 
representation of a data set. 

We start with a basic bar plot.

```{r}
ggplot(df, aes(x = fuel)) + 
    geom_bar() + 
    coord_flip() + 
    ggp
```

## Order by frequency

The `fct_infreq` function will order the factor levels by their frequency. 

```{r}
ggplot(df, aes(x = fct_infreq(fuel))) + 
    geom_bar() + 
    coord_flip() + 
    ggp
```

## Order by their first appearance in the data

The `fct_inorder` function will order the factor levels by the order they 
appear in the data set. 

```{r}
ggplot(df, aes(x = fct_inorder(fuel))) + 
    geom_bar() + 
    coord_flip() + 
    ggp
```

## Lump together rare factor levels

Sometimes we have a large number of factor levels, many of which are very rare. 
The [`fct_lump_*`](https://forcats.tidyverse.org/reference/fct_lump.html) set
of functions can be used to group together rare levels into an "Other" category.
Here we illustrate the use of the `fct_lump_n` function, which lumps 
together all levels except for the `n` most frequent ones.

```{r}
ggplot(df, aes(x = fct_infreq(fct_lump_n(fuel, n = 3, other_level = "Other")))) + 
    geom_bar() + 
    coord_flip() + 
    ggp
```

## Reorder one factor by the values of another variable

The `fct_reorder` function can be used to reorder the levels of a factor by 
the value of another variable. 

<!-- For example, to plot library sizes of samples, ordered by experiment.-->

```{r}
ggplot(df %>% group_by(class) %>% summarize(mean_hwy = mean(hwy)), 
       aes(x = fct_reorder(class, mean_hwy), y = mean_hwy)) + 
    geom_col() + 
    coord_flip() + 
    ggp

ggplot(df %>% group_by(class) %>% summarize(mean_hwy = mean(hwy)), 
       aes(x = fct_reorder(class, mean_hwy), y = mean_hwy)) + 
    geom_point() + 
    coord_flip() + 
    ggp
```

# Faceting

Faceting splits a plot into several panels according to the value of a given 
variable.
There are several faceting function in `ggplot2`, and additional ones 
provided in extension packages to address missing functionality. 

## `facet_wrap` 

The `facet_wrap` function wraps a sequence of panels into a 2-dimensional 
layout. 
We can set the number of rows or columns to split the panels over.

```{r}
## Default
ggplot(df, aes(x = hwy, y = cty)) +
    geom_point() + 
    facet_wrap(~ fct_lump_n(fuel, n = 3, other_level = "Other")) + 
    ggp

## Set number of rows
ggplot(df, aes(x = hwy, y = cty)) +
    geom_point() + 
    facet_wrap(~ fct_lump_n(fuel, n = 3, other_level = "Other"), nrow = 1) + 
    ggp
```

By default, the x- and y-axes are shared between the panels. 
The `scales` argument can be used to set either or both of them to be "free" 
(i.e., panel-specific). 
Setting `scales = "free"` decouples both the x- and y-axes, setting it to 
`"free_x"` or `"free_y"` decouples only one of the axes. 

```{r}
ggplot(df, aes(x = hwy, y = cty)) +
    geom_point() + 
    facet_wrap(~ fct_lump_n(fuel, n = 3, other_level = "Other"), 
               scales = "free") + 
    ggp
```

## `facet_grid`

The `facet_grid` function places the set of panels in a matrix layout, where 
each dimension is determined by a given variable. 
It is typically most useful when we want to stratify by two discrete variables. 

```{r, fig.width = 10, fig.height = 10}
ggplot(df, aes(x = hwy, y = cty)) +
    geom_point() + 
    facet_grid(fct_lump_n(class, n = 3) ~ 
                   fct_lump_n(fuel, n = 3, other_level = "Other")) + 
    ggp
```

We can set `scales = "free"` also here, but note that it will affect the 
entire rows/columns in the same way (i.e., panels are not completely 
decoupled).

```{r, fig.width = 10, fig.height = 10}
ggplot(df, aes(x = hwy, y = cty)) +
    geom_point() + 
    facet_grid(fct_lump_n(class, n = 3) ~ 
                   fct_lump_n(fuel, n = 3, other_level = "Other"),
               scales = "free") + 
    ggp
```

## Faceting bar plots with different numbers of categories in each facet

Faceting with bar plots may require extra attention, if not all facets 
contain the same set of categories. 

Using `facet_wrap` with `scales = "fixed"` leaves a missing bar for empty 
categories. 

```{r, fig.width = 10}
ggplot(df, aes(x = fct_lump_n(make, n = 3))) +
    geom_bar() + 
    facet_wrap(~ fct_lump_n(fuel, n = 3, other_level = "Other"), 
               scales = "fixed", nrow = 1) + 
    ggp
```

Using `facet_wrap` with scales = "free" doesn't leave empty space, but the 
bars are of different width. 

```{r, fig.width = 10}
ggplot(df, aes(x = fct_lump_n(make, n = 3))) +
    geom_bar() + 
    facet_wrap(~ fct_lump_n(fuel, n = 3, other_level = "Other"), 
               scales = "free", nrow = 1) + 
    ggp
```

The `facet_grid` function lets us adjust the space allocated to each facet, 
in order to keep the bar widths the same but not leave empty space for missing
categories, but keeps the y-axis the same across the panels. 

```{r, fig.width = 10}
ggplot(df, aes(x = fct_lump_n(make, n = 3))) +
    geom_bar() + 
    facet_grid(~ fct_lump_n(fuel, n = 3, other_level = "Other"), 
               scales = "free", space = "free") + 
    ggp
```

Finally, the `facet_row` function from the `ggforce` package lets us adjust 
the space allocated to each facet and at the same time use a free y-axis.

```{r, fig.width = 10}
ggplot(df, aes(x = fct_lump_n(make, n = 3))) +
    geom_bar() + 
    facet_row(~ fct_lump_n(fuel, n = 3, other_level = "Other"), 
               scales = "free", space = "free") + 
    ggp
```

## Showing all the data as 'background' in each facet

Sometimes we would like to show all the data as the "background" in each 
facet, while highlighting the points corresponding to the specific facet. 
This can be achieved in several ways. 
A neat trick is to add an additional layer using a modified data set where the 
faceting variable is removed:

```{r}
ggplot(df, aes(x = hwy, y = cty)) +
    geom_point(data = transform(df, fuel = NULL), colour = "grey80") +
    geom_point() + 
    facet_wrap(~ fct_lump_n(fuel, n = 3, other_level = "Other"), 
               scales = "free") + 
    ggp
```

Another option is to use the `gghighlight` package. 
The package can be used to highlight points in a single panel:

```{r}
ggplot(df %>% mutate(fuel_lumped = fct_lump_n(fuel, n = 3, other_level = "Other")),
       aes(x = hwy, y = cty)) +
    geom_point(aes(color = fuel_lumped)) + 
    gghighlight(fuel_lumped == "Premium") + 
    ggp
```

Or to highlight all points, and additionally facet:

```{r}
ggplot(df %>% mutate(fuel_lumped = fct_lump_n(fuel, n = 3, other_level = "Other")),
       aes(x = hwy, y = cty)) +
    geom_point(aes(color = fuel_lumped)) + 
    gghighlight() + 
    facet_wrap(~ fuel_lumped, scales = "free") + 
    ggp
```

If the number of highlighted points is not too large, `gghighlight` will add 
a label for each point. 

```{r}
ggplot(df %>% mutate(fuel_lumped = fct_lump_n(fuel, n = 3, other_level = "Other")),
       aes(x = hwy, y = cty)) +
    geom_point() + 
    gghighlight(hwy - cty > 15 | ((abs(hwy - 60) < 10) & (abs(cty - 75) < 10)), 
                label_key = make, max_highlight = 25) + 
    ggp
```


# Adjusting widths of bars in bar plots

We saw above how to adjust the widths of panels in facetted bar plots. 
Here, we will instead see how to adjust the widths of individual bars, when 
displayed side-by-side in a single panel. 

The default layout of a bar plot where each bar is further split by a 
variable is to stack the components on top of each other: 

```{r}
ggplot(df, aes(x = fct_lump_n(fuel, n = 3, other_level = "Other"), 
               fill = fct_lump_n(make, n = 3))) +
    geom_bar() + 
    ggp
```

We can also get the bars side-by-side by setting the `position` argument 
(either `position = "dodge"` or `position = position_dodge()`). 
However, if there are different numbers of subcategories, the bars will have 
different widths. 

```{r}
ggplot(df, aes(x = fct_lump_n(fuel, n = 3, other_level = "Other"), 
               fill = fct_lump_n(make, n = 3))) +
    geom_bar(position = position_dodge()) + 
    ggp
```

We can use the `position_dodge2()` function to preserve the widths of the 
bars. 
However, the categories will be centered for each value on the x-axis, 
which means that the same bar will not always appear in the same relative 
position.

```{r}
ggplot(df, aes(x = fct_lump_n(fuel, n = 3, other_level = "Other"), 
               fill = fct_lump_n(make, n = 3))) +
    geom_bar(position = position_dodge2(preserve = "single")) + 
    ggp
```

In order to keep the widths of the bars and at the same time place them in 
consistent relative positions for each value on the x-axis, one way is to 
first summarize the data, making sure to represent the empty categories with 
a count of zero, and then using the code in the previous chunk to preserve 
the widths of the bars.

```{r}
## Side-by-side bar plot with consistent width and position
ggplot(df %>% mutate(fuel = fct_lump_n(fuel, n = 3, other_level = "Other"), 
                     make = fct_lump_n(make, n = 3)) %>%
           count(fuel, make) %>%
           complete(fuel = unique(fuel), make = unique(make), 
                    fill = list(n = 0)), 
       aes(x = fuel, y = n, fill = make)) + 
    geom_bar(stat = "identity", position = position_dodge2(preserve = "single")) + 
    ggp
```


# Changing scales for axes

## Axes with percent (%) values

```{r}
## scales::percent will multiply by 100
ggplot(df, aes(x = fct_lump_n(fuel, n = 3, other_level = "Other"), 
               fill = fct_lump_n(make, n = 3))) +
    geom_bar(position = "fill") + 
    scale_y_continuous(labels = scales::percent) + 
    labs(y = "Percentage") + 
    ggp

## scales::percent_format has more arguments
ggplot(df, aes(x = fct_lump_n(fuel, n = 3, other_level = "Other"), 
               fill = fct_lump_n(make, n = 3))) +
    geom_bar(position = "fill") + 
    scale_y_continuous(labels = scales::percent_format(scale = 100, accuracy = 0.01)) + 
    labs(y = "Percentage") + 
    ggp
```

## Limit axis range

```{r}
## xlim() + ylim() will replace out-of-range data by NA
ggplot(df, aes(x = hwy, y = cty)) +
    geom_point(size = 8, shape = 1) +
    xlim(11, 55) + 
    ggp

## coord_cartesian() just sets the displayed range
ggplot(df, aes(x = hwy, y = cty)) +
    geom_point(size = 8, shape = 1) +
    coord_cartesian(xlim = c(11, 59)) + 
    ggp
```

# Interactive plots

Be careful - these plots may get very big!

```{r}
## Turn a ggplot into an interactive plot with ggplotly
ggplotly(
    ggplot(df %>% dplyr::filter(year == 2005), aes(x = hwy, y = cty, 
                                                   label = make)) +
        geom_point() + 
        ggp,
    tooltip = c("label", "x", "y", "text")
)
```

- `ggiraph`

# Titles, subtitles and captions

```{r}
ggplot(df %>% dplyr::filter(year == 2005), aes(x = hwy, y = cty)) +
    geom_point() + 
    labs(title = "This is the title", 
         subtitle = "And a subtitle",
         caption = "And the caption goes here",
         x = "Highway fuel economy (mpg)",
         y = "City fuel economy (mpg)") + 
    ggp
```

Note that not all of these are compatible with interactive plots:

```{r}
ggplotly(
    ggplot(df %>% dplyr::filter(year == 2005), aes(x = hwy, y = cty)) +
        geom_point() + 
        labs(title = "This is the title", 
             subtitle = "And a subtitle",
             caption = "And the caption goes here",
             x = "Highway fuel economy (mpg)",
             y = "City fuel economy (mpg)") + 
        ggp
)
```

# Adding statistical information to plots

- `ggsignif`, `ggstatsplot`

# Adding text and annotation

```{r}
## ggforce
ggplot(df %>% dplyr::filter(year == 2005), aes(x = hwy, y = cty)) +
    geom_point() + 
    geom_mark_ellipse(aes(label = "Interesting points", 
                          description = "These points are interesting",
                          filter = (cty - hwy) > 1), 
                      fill = "pink") + 
    ggp

## ggalt
ggplot(iris, aes(x = Petal.Width, y = Sepal.Width, colour = Species)) +
    geom_point() + 
    geom_encircle(aes(group = Species)) + 
    ggp
```

```{r}
## gghighlight
ggplot(diamonds %>% group_by(carat, cut) %>% summarize(mean_price = mean(price)),
       aes(x = carat, y = mean_price, color = cut)) +
    geom_line() + 
    gghighlight(cut %in% c("Good", "Ideal")) + 
    facet_wrap(~ cut) + 
    ggp
```


- `geomtextpath`
- `ggtext`
- `ggrepel`
- add number of values in bar plot (https://r-graphics.org/recipe-bar-graph-labels)

# Customizing legends

```{r}
## legend position (outside of plot)
## allowed values for the arguments legend.position are:
## "left", "top", "right", "bottom"
ggplot(df, aes(hwy, cty, color = fuel)) +
    geom_point() +
    ggp + 
    theme(legend.position = "bottom")

## number of rows (discrete scales)
ggplot(df, aes(hwy, cty, color = fuel)) +
    geom_point() + 
    ggp +
    theme(legend.position = "bottom") +
    guides(color = guide_legend(nrow = 5))

## override graphical parameters
ggplot(diamonds, aes(carat, price, color = cut)) +
    geom_point(size = 1, alpha = 0.1) + 
    ggp +
    theme(legend.position = "bottom") +
    guides(color = guide_legend(override.aes = list(size = 4, alpha = 1)))

## move legend inside plot
## c(0,0) corresponds to the “bottom left” and
## c(1,1) corresponds to the “top right” position
ggplot(diamonds, aes(carat, price, color = cut)) +
    geom_point(size = 1, alpha = 0.1) + 
    ggp +
    theme(legend.position = c(1, 0),
          legend.justification = c(1, 0)) +
    guides(color = guide_legend(override.aes = list(size = 4, alpha = 1)))
```

# Specifying color palettes

```{r}
## One-sided gradient
ggplot(df %>% dplyr::filter(year == 2005), aes(x = hwy, y = cty, color = cyl)) +
    geom_point() + 
    scale_color_gradient(low = "white", high = "darkblue") + 
    ggp

## Two-sided gradient
ggplot(df %>% dplyr::filter(year == 2005), aes(x = hwy, y = cty, color = scale(cyl))) +
    geom_point() + 
    scale_color_gradient2(low = "red", mid = "white", high = "darkblue", 
                          midpoint = 0) + 
    ggp

## Custom gradient
ggplot(df %>% dplyr::filter(year == 2005), aes(x = hwy, y = cty, color = scale(cyl))) +
    geom_point() + 
    scale_color_gradientn(colours = hcl.colors(9, "Spectral")) + 
    ggp

## viridis continuous colors
## viridis_c - continuous
## viridis_b - binned
## viridis_d - discrete
ggplot(df %>% dplyr::filter(year == 2005), aes(x = hwy, y = cty, color = scale(cyl))) +
    geom_point() + 
    scale_color_viridis_c() + 
    ggp

## Manual colors
ggplot(df, aes(x = fct_lump_n(fuel, n = 3, other_level = "Other"), 
               fill = fct_lump_n(make, n = 3))) +
    geom_bar(position = "fill") + 
    scale_fill_manual(values = c(BMW = "darkblue", Chevrolet = "red", 
                                 Ford = "forestgreen", Other = "grey85"),
                      name = "Make") + 
    ggp

## Colors from existing palettes
## RColorBrewer palettes
display.brewer.all()
ggplot(df, aes(x = fct_lump_n(fuel, n = 3, other_level = "Other"), 
               fill = fct_lump_n(make, n = 3))) +
    geom_bar(position = "fill") +
    scale_fill_brewer(palette = "Set2", name = "Make") + 
    ggp

ggplot(df, aes(x = fct_lump_n(fuel, n = 3, other_level = "Other"), 
               fill = fct_lump_n(make, n = 3))) +
    geom_bar(position = "fill") +
    scale_fill_brewer(palette = "Greens", name = "Make") + 
    ggp

## 'viridis' colors
ggplot(df, aes(x = fct_lump_n(fuel, n = 3, other_level = "Other"), 
               fill = fct_lump_n(make, n = 3))) +
    geom_bar(position = "fill") +
    scale_fill_viridis_d() + 
    ggp

## multiple scales for color or fill: ggnewscale::new_scale
ggplot(df %>% dplyr::filter(year == 2005), aes(x = hwy, y = cty, color = cyl)) +
    geom_point(size = 3) + 
    scale_color_viridis_c() +
    new_scale("color") +
    geom_point(aes(color = fuel), shape = 21, size = 4, stroke = 1) +
    scale_color_brewer(palette = "Dark2") + 
    ggp

## cap color range
## - one way of doing it: limit color range + set color for out-of-range NA values
cols <- hcl.colors(8)
ggplot(diamonds, aes(x = carat, y = depth, color = price)) +
    geom_point() +
    scale_color_gradientn(colors = cols,
                          limits = c(min(diamonds$price), 10000),
                          na.value = cols[length(cols)]) + 
    ggp

```

# Using `after_stat` (previously `..*..`)

```{r}
## Histogram...
ggplot(df %>% dplyr::filter(year == 2005), aes(x = hwy)) +
    geom_histogram(bins = 30) + 
    ggp

## ...is equivalent to
ggplot(df %>% dplyr::filter(year == 2005), aes(x = hwy, y = after_stat(count))) +
    geom_histogram(bins = 30) + 
    ggp

## To get density instead:
ggplot(df %>% dplyr::filter(year == 2005), aes(x = hwy, y = after_stat(density))) +
    geom_histogram(bins = 30) + 
    ggp

## In percentage
ggplot(df %>% dplyr::filter(year == 2005), aes(x = hwy, y = after_stat(density))) +
    geom_histogram(bins = 30) + 
    scale_y_continuous(labels = scales::percent) + 
    ggp

## Other transformations - scale so that max height = 1
ggplot(df %>% dplyr::filter(year == 2005), aes(x = hwy, y = after_stat(count/max(count)))) +
    geom_histogram(bins = 30) + 
    ggp
```



# Combining plot panels

```{r}
g1 <- ggplot(df, aes(x = fct_lump_n(fuel, n = 3, other_level = "Other"), 
                     fill = fct_lump_n(make, n = 3))) +
    geom_bar(position = "fill") +
    scale_fill_brewer(palette = "Set2", name = "Make") + 
    ggp
g2 <- ggplot(df %>% dplyr::filter(year == 2005), aes(x = hwy, y = cty, color = scale(cyl))) +
    geom_point() + 
    scale_color_gradient2(low = "red", mid = "white", high = "darkblue", 
                          midpoint = 0) + 
    ggp
g3 <- ggplot(df %>% group_by(class) %>% summarize(mean_hwy = mean(hwy)), 
             aes(x = fct_reorder(class, mean_hwy), y = mean_hwy)) + 
    geom_point() + 
    coord_flip() + 
    ggp
(g12 <- cowplot::plot_grid(g1, g2 + theme(legend.position = "none"),
                           ncol = 1, labels = c("A", "B"), align = "v"))
(g12 <- cowplot::plot_grid(g1, g2 + theme(legend.position = "none"),
                           ncol = 1, labels = c("A", "B"), align = "v", axis = "lr"))
cowplot::plot_grid(g12, g3, nrow = 1, labels = c("", "C"))
```

```{r}
get_legend(g1)
cowplot::plot_grid(g1 + theme(legend.position = "none"), 
                   g1 + theme(legend.position = "none"), 
                   get_legend(g1), 
                   nrow = 1, rel_widths = c(1, 1, 0.4))
```

`cowplot` doesn't work directly with the output of `ggpairs`, for example:

```{r, fig.width = 10, error = TRUE}
gp <- ggpairs(df %>% dplyr::select(cty, hwy, cyl))
cowplot::plot_grid(gp, g1)
```

However, it works like this:

```{r, fig.width = 10}
cowplot::plot_grid(ggmatrix_gtable(gp), g1)
```


```{r}
## patchwork
g1 | g2
g1 / g2 + theme(legend.position = "none")
(g1 / g2) | g3
```


- shared title


# Other material, sources for some of the material presented above

- [https://uc-r.github.io/ggplot](https://uc-r.github.io/ggplot)
- [https://exts.ggplot2.tidyverse.org/gallery/](https://exts.ggplot2.tidyverse.org/gallery/)
- [https://www.youtube.com/watch?v=8ikFe82Mb1I&ab_channel=R-LadiesTunis](https://www.youtube.com/watch?v=8ikFe82Mb1I&ab_channel=R-LadiesTunis)
- [https://stulp.gmw.rug.nl/ggplotworkshop/advancedggplot.html#showing-all-data-in-facets](https://stulp.gmw.rug.nl/ggplotworkshop/advancedggplot.html#showing-all-data-in-facets)
- [https://stackoverflow.com/questions/61922380/preserve-location-of-missing-columns-in-combined-bar-plot](https://stackoverflow.com/questions/61922380/preserve-location-of-missing-columns-in-combined-bar-plot)

# Session info

```{r}
sessioninfo::session_info()
```

